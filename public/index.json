[{"content":"Introduction So, after you are done with the book and implemented your first 8-bit CPU you keep wondering\nok, but now I want to do real world stuff\nHere I got you back, nothing comes before when it comes to real world stuff that having the capability of sending data to/from other devices. When I began my personal projects, when I got my Arty A7, I thought that I needed to be able to debug what\u0026rsquo;s happening inside the FPGA when the internal logic analyzer might not be too reliable (pro-tip: it\u0026rsquo;s very reliable). So being able to send to a computer data using a simple protocol is a must.\nUART comes as the best option for easy communication, as the baudrate is not too high to need complicated timing analysis, but complex enough to be a funny first project to learn the basics of digital design applied to real world, with real constraints and specifications.\nWhat is this UART then? UART (universal asynchronous receiver-transmitter) is a serial protocol of communication that doesn\u0026rsquo;t require tight clock sync between transmitter (TX) and receiver (RX). Basically, the TX pulls the wire down to tell the RX that it needs to start listening, sends some bits of data one at time, maybe some parity bits and ends the transmission by setting the wire to high. Indeed, the wire is in resting state when it\u0026rsquo;s kept high.\nExample of UART signal\nAs you can see from the picture, 8 bits are sent, no parity bit is sent, there is the starting signal (pull down) and the end signal (pull up). The transmission is in idle when the wire is kept high. The other condition is that the least significant bit (LSB) is sent first. For example, in the transmission above, the byte 8'h4B will be sent starting by the h4 symbol, just reversed, later the hB symbol, reversed as well.\nHow do I implement the UART thing? Even before writing a single line of code, let\u0026rsquo;s put down a strategy on how to make this block and also how to verify it.\nFunctional blocks So, we have for the UART the transmitter TX and the receiver RX. The properties of those blocks should be such when there is a signal to enable communication they will start processing in a blocking way, that means they will process one byte at time and notify when this processing is finished so that the next one can start. From a top level perspective, we have then:\nUART blocks\nBasically, we will need two blocks: the TX that will get the data, the starting signal and return the UART stream to the PC and a notification when it\u0026rsquo;s done, and the RX that will get the incoming stream from the PC and notify when it\u0026rsquo;s done, providing the data at it\u0026rsquo;s output.\nHow do I verify this is working? We will have to prepare a testbench, where we will chain some UART input data, use the RX to decode the stream, then send this very same data to the TX, where the expected result should be a UART stream that is equal but delayed as the input signal, very easy for verification, but since I\u0026rsquo;m kind of lazy, I will chain another RX, and make sure that the chaining of data-\u0026gt;RX-\u0026gt;TX-\u0026gt;RX yields the same decoded data.\nSo, let\u0026rsquo;s see at the details of each block now\nTX The TX, as indicated in the picture above, takes an input data from a register, the order to start transmitting, and it will raise a busy flag while it\u0026rsquo;s serializing the data to indicate a potential FIFO or whatever is feeding with data the TX to not send any more until the flag is lowered. However, the TX should be ready to start as soon as it\u0026rsquo;s finished. For this, it comes to help the ending bit: while it\u0026rsquo;s pulled up for one period, the TX gets ready to receive the next byte of data.\nTo do this, we will rely on a finite state machine (FSM from now on), indicating at what step of the process the transmitter is. We will also be indicating at the block the baud rate for the transmission and since I\u0026rsquo;m using for this particular example the clock of the Arty A7 (100MHz), I will indicate this as a parameter. The goal is to tell the circuit, via a counter, how many clock cycles each period of the UART signal requires to transition to the next state\n1 2 3 4 5 6 7 8 parameter SYSCLK = 100_000_000; // MHz parameter BAUDRATE = 57600; parameter DIVISOR = SYSCLK/BAUDRATE; enum reg [3:0] {IDLE, INIT, BIT8, BIT7, BIT6, BIT5, BIT4, BIT3, BIT2, BIT1, BIT0} state=IDLE, next_state=IDLE; reg [8:0] temp_buf = 9\u0026#39;b111111111; reg [13:0] strobe = 14\u0026#39;b1; The strobe signal is this counter, and when the counter reaches the required number of clock cycles, it will reset and command the next state to take over. Also, you can see I\u0026rsquo;m not explicitly indicating the final state, as I will consider as an idle state that will be capable of already receiving commands for the next byte to be transmitted.\nFor the sake of verification on simulation, I will be indicating an initial state for some variables. Those lines aren\u0026rsquo;t necessarily synthesizable, but are of great help and will avoid a lot of debugging later on simulation. Then, the main process is placed under a flip-flop (that posedge mixed with reg in its content). As you can see, when the strobe reach zero, the state is updated, the counter is reset to the value of DIVISOR and the output is set to the newest bit, else it will keep counting down. Another feature, if we are in the IDLE state we don\u0026rsquo;t count, the circuit is frozen. This is not that useful but I don\u0026rsquo;t like polar bears swimming around Italy because global warming.\n1 2 3 4 5 6 7 initial {txd, tx_busy} = {1\u0026#39;b1, 1\u0026#39;b0}; always @(posedge clk) begin {state, txd} \u0026lt;= (strobe == 14\u0026#39;b0) ? {next_state, temp_buf[0]} : {state, txd}; if (strobe == 14\u0026#39;b0) strobe \u0026lt;= (next_state == IDLE) ? 14\u0026#39;b0 : DIVISOR - 1; else strobe \u0026lt;= strobe - 14\u0026#39;b1; end Finally, we define the transitions of the state machine and assign the busy flag up whenever we are busy processing data. Also, notice we are updating the temp_buf as a shift register. This is another subtlety, as it\u0026rsquo;s more expensive to place many switches on the place of the requested array than just shift the data and take the last bit. This will also help with filling with 1'b1s, so that\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 always @(posedge clk) begin case(state) IDLE: {next_state, temp_buf} \u0026lt;= (i_wr \u0026amp;\u0026amp; !tx_busy) ? {INIT, {data, 1\u0026#39;b0}} : {next_state, temp_buf}; INIT: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT8, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT8: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT7, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT7: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT6, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT6: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT5, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT5: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT4, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT4: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT3, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT3: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT2, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT2: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT1, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT1: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {IDLE, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; endcase end assign tx_busy = state!=IDLE; There you got, as promised an easy block, few lines of HDL where we abide to basic rules of digital design. Now let\u0026rsquo;s take a look at the receiver\nRX This block is not more complicated, but it has a subtletly: a real line when idle, for any reason, can be pulled by noise, cross talking, electromagnetic interference, etc. into a low state. This is a false positive for the starting of the transmission and we don\u0026rsquo;t want to catch it. Also, unlike the transmitter, we want to sample the data not at the begining but at the middle of the UART period, this is because you never know the quality of the signal you are receiving, and if the cable is very long, lossy or don\u0026rsquo;t have enough power to driver the RX input capacitance, the signal might not settle correctly if we don\u0026rsquo;t give it enough time.\nSo, in the same ways as before, we define some parameters for the baud rate, the initial value of some variables and the states of the RX:\n1 2 3 4 5 6 7 8 9 10 parameter SYSCLK = 100_000_000; // MHz parameter BAUDRATE = 57600; parameter DIVISOR = SYSCLK/BAUDRATE; enum reg [3:0] {IDLE, BIT8, BIT7, BIT6, BIT5, BIT4, BIT3, BIT2, BIT1, BIT0} state=IDLE, next_state=IDLE; reg [13:0] strobe = 14\u0026#39;b0; reg [7:0] temp_buf = 8\u0026#39;b11111111; initial data = 8\u0026#39;b0; The logic on the state machine. Same as before, if the state is in IDLE we just stop the counter. Here, we also define the rule for updating the output in such a way that hides the inner process, setting it at the final value only when we are about to set the state into idling.\n1 2 3 4 5 6 7 8 9 always @(posedge clk) begin state \u0026lt;= (strobe == 14\u0026#39;b0) ? next_state : state; if (strobe == 14\u0026#39;b0) strobe \u0026lt;= ((state == IDLE) \u0026amp; rxd) ? 14\u0026#39;b0 : DIVISOR - 1; else strobe \u0026lt;= strobe - 14\u0026#39;b1; end always @(posedge clk) begin data \u0026lt;= (next_state==IDLE) ? temp_buf : data; end Finally, the update rules for the FSM, and we set the flag for the rx_done to one, but only for one clock cycle. This is because this way I can chain a RX and a TX and make echo requests with the UART. Also, notice that we set the next_state at the middle of the counter for the reasons indicated at the beginning of this section\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 always @(posedge clk) begin case(state) IDLE: {next_state, temp_buf} \u0026lt;= ((strobe==DIVISOR/2) \u0026amp; !rxd) ? {BIT8, {8\u0026#39;b00000000}} : {next_state, temp_buf}; BIT8: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT7, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT7: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT6, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT6: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT5, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT5: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT4, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT4: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT3, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT3: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT2, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT2: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT1, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT1: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {IDLE, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; endcase end assign rx_done = (state==IDLE) \u0026amp; (next_state==IDLE); Simulation For testing this block, I will feed the RX with some premade data stream, and chain RX to TX to RX and check the values of the processed data and the UART signals. Also, via parameter, I will set the baud rate of the UART to 25Mbaud, so that the counter needs to count 4 clocks and the simulation doesn\u0026rsquo;t get too long.\n1 2 3 4 5 6 7 8 9 10 parameter BAUDRATE = 25000000; reg tb_clk = 1\u0026#39;b0; reg [29:0] pattern = {1\u0026#39;b1,8\u0026#39;h5A,1\u0026#39;b0,1\u0026#39;b1,8\u0026#39;hC6,1\u0026#39;b0,1\u0026#39;b1,8\u0026#39;hE6,1\u0026#39;b0}; reg [4:0] npat = 5\u0026#39;b11101; assign rxd = pattern[npat]; always #10 tb_clk \u0026lt;= !tb_clk; always #80 npat \u0026lt;= npat==29 ? 5\u0026#39;b00000 : npat + 1; The resulting signals are as follows:\nUART Simulation in Vivado\nIn the picture you can see the RX received the stream defined in reg [29:0] pattern and when it\u0026rsquo;s done it pass directly the data to the TX, then the TX will process and send the data to the verification RX, hence there will be a delay from TX to verification RX of about 9 symbols, without wasting clock cycles between one byte and another.\nConclusion Together with you, this is the first block I created in my Arty A7 that I can consider a complete project. It pass a complete run of simulation and when implemented in the FPGA the echo functionality works. My next steps it\u0026rsquo;s to stress test this block by making a loop and sending pseudo-random data while checking the bit error rate.\nIf you want to get the sources of these blocks, as I write this blog I will place them at my github repo\n","permalink":"https://danielhacks.it/blog/20250529_uart_for_practice/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eSo, after you are done with the book and implemented your first 8-bit CPU you keep wondering\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eok, but now I want to do real world stuff\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eHere I got you back, nothing comes before when it comes to real world stuff that having the capability of sending data to/from other devices. When I began my personal projects, when I got my Arty A7, I thought that I needed to be able to debug what\u0026rsquo;s happening inside the FPGA when the internal logic analyzer might not be too reliable (pro-tip: it\u0026rsquo;s very reliable). So being able to send to a computer data using a simple protocol is a must.\u003c/p\u003e","title":"UART: the basics after you know the very basics"},{"content":"Introduction If you are a hardware engineer you need no explanation though, this is more for the programming guys who attempt to make things with an FPGA in the belief that is the next step of Arduino (I do think that though, so no judgment made here)\nAs someone who wrote a lot of code in my young age (still loving fiddling with Linux kernel), I\u0026rsquo;m lucky I got the purpose of HDL.\nGiven the amount of times I have seen the question raised on stackoverflow or reddit on the struggle of programmers that approach the field of digital design, this is not a wasted question. So what is even HDL?\nWhat is HDL? Basically it stands for Hardware Definition Language. Still a language but not for programming on a Turin machine.\nSo, for the software programming team, but those who do real programming (hence know at least Lisp, preferable Haskell), this is kind of functional language. It is actually a netlist language, where you describe the connections of digital circuitry, input to the block (HDL module) and the outputs that will go somewhere. And this pretty much resembles the behavior of functions (more than zero inputs, at least one output). So, if you know your functionals languages, you will fare very well with HDL. Else I pretty much recommend Haskell as your next step in programming muscles.\nIn this blog I will mainly write in SystemVerilog, a superset of Verilog, which is one of the most popular hardware definition languages. The other one that is out there is VHDL. As usual, they both are capable of doing pretty much what\u0026rsquo;s needed for having the job done, it\u0026rsquo;s a matter of preference (or what you are forced to use in your workplace).\nWhat is this wire and reg In logic design you have ones and zeros. Sometimes some floating piece of metal that is not connected to anything of something which you can\u0026rsquo;t tell what\u0026rsquo;s the current state when you plug a supply (remember, we are still talking about circuits, forget definite initial states).\nA wire is an element that alike a real wire, can carry information from point A to point B. That\u0026rsquo;s all. In HDL, you need to define wires so that you can differentiate by labels the connections from one module to another. An example in here:\n1 2 3 4 wire bus_in1, bus_in2; wire bus_out; assign bus_out = and(bus_in1, bus_in2); Let me reiterate once again: we are dealing with logic, which is akin to functions (some inputs, at least one output). With wires, we defined where this and() element (the circuit for the logic AND operation) is connected. Perhaps also which whom.\nThey are just labels you use to identify connections\nInstead, the reg is just like a wire that can store its state, like a memory element. Here comes the confusion oftentimes, as a wire is not a complicated circuit, just a piece of conductor. Instead, whatever gets synthesized by a reg ends having some transistors. Hence, a reg will synthesize either a latch (a memory element that\u0026rsquo;s dependent on the level) or a flip-flop (a memory element that\u0026rsquo;s dependent on the transition of a control signal, almost always a clock).\nIf you don\u0026rsquo;t know what latches or flipflops are, here is a brief explanation:\nA latch is a memory element that sets the output equal to the input when actively driven. When no driving is given to the latch (no electrons in the input, or floating input) it preserves the last state. A flip-flop will propagate the state of the input to the output only when a transition either from zero to one (raising or positive edge) or from one to zero (falling or negative edge) happens.\nAs a general rule, in digital design you avoid latches as are very technology dependent on their implementation (they can be very power hungry sometimes). From now on let\u0026rsquo;s set the rule that we will try to synthesize only flip-flops.\nThey said HDL has intrinsic parallelism HLD is as much parallel as two logic gates working at the same time. You describe the logical circuits and nothing stops it from making two operations at the very same time (disregarding propagation delay in logic gates). In this way, the parallelism is really explicit.\nSo can I do a for loop? Hardware Definition Language!\nTry to make a for loop out of AND/OR/NOT gates on a breadboard. Sure you can, but there are better ways to make a loop that save components (fewer components, less area, less power wasted, polar bears not floating around Sicily).\nYup, when you shitpost on reddit global warming send beards to Sicily\nHowever, for all the effects, HDL is capable of parsing a for loop, as it will infer the attempt of the engineer and generate the equivalent circuit that reproduces that behavior. You can pretty much describe the behavior of your circuit in HDL, no warranties that the synthesis will be the best one for a certain algorithm.\nAgain, team Haskell wins here against team Java (lol). Recursion basically is a way of making pipelines in digital design.\nSo, am I ready to write HDL after reading this? Let\u0026rsquo;s be honest: you were always ready to make digital circuits, just that your mindset was obfuscated by the prejudice that HDL are programming languages. Now that you know they aren\u0026rsquo;t, and you know that they basically describe the connections and/or behavior of logical circuits, the doors are open for you. But for the sake of making a framework that will allow you to make good designs, let\u0026rsquo;s put this set of rules:\nWhen use the always @(posedge clk) or always @(negedge clk) to create flip-flops, strive for always and unconditionally use real clock signals. Avoid as much as possible using other signals Never synthezise latches. The synthesis tool usually reports when this happens, but a basic rule is to never put a reg variable under an always statement that doesn\u0026rsquo;t contain either posedge or negedge Avoid for or while loops as much as you can, the better you are, the less you need them. Abuse case(variable) whenever you can Avoid loops. In HDL everything happens at the same time, so something like this 1 2 3 4 5 always @(a, b, c) a = b; b = c; c = a; end will fail miserably as you just created a ring of buffers\n","permalink":"https://danielhacks.it/blog/20250527_what-is-hdl/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you are a hardware engineer you need no explanation though, this is more for the programming guys who attempt to make things with an FPGA in the belief that is the next step of Arduino (I do think that though, so no judgment made here)\u003c/p\u003e\n\u003cp\u003eAs someone who wrote a lot of code in my young age (still loving fiddling with Linux kernel), I\u0026rsquo;m lucky I got the purpose of HDL.\u003c/p\u003e","title":"What Is HDL? The explanation you did not requested"},{"content":"Who am I? Valeggio, 2023\nI\u0026rsquo;m Daniel, a microelectronics engineer working on cutting edge optical links, but with a general passion for electronics since I was 13 years old. Based in Italy, from the best analog microelectronics school around (and they know it).\nWhat is this blog about In principle, I wanted to make a web log for my learning activity on digital design and FPGA. But well in the deep, I\u0026rsquo;m an analog circuit designer, and even deeper, a physicist. So I guess at some point the arguments will diverge onto many of my interests. But what blog writer doesn\u0026rsquo;t do that?\nWhy is this blog necessary? I used to write blogs back in the 2010s about machine learning, data science and numerical simulation of complex systems. With the years I moved onto different things and removed the blog references. But in the end I like the learning process that allows the writing and summarizing information. If other people can understand it, that means I got it right. Akin to the teacher learning from the student, just that the student is me as well.\nSo basically, it is necessary for me, but with the hope that the quality is high enough so that you can leverage on this information as well.\nWhy there is that little shack in the navbar? Among many of my dreams, there is this dream of going off the grid (partially). So I\u0026rsquo;m looking for ways to have this small house in the mountains, some mini cows, mini donkeys, goats, chickens and Wi-Fi to keep doing what I love. This blog itself is a move towards that future, hence I see the point on putting a symbol of my end goal somewhere around where I don\u0026rsquo;t lose sight of it.\nPublications 1 A 200Gb/s Low Power DSP-Based Optical Receiver and Transmitter with Integrated TIA and Laser Drivers\n2 A 5nm 60GS/s 7b 64-Way Time Interleaved Partial Loop Unrolled SAR ADC Achieving 34dB SNDR up to 32GHz\n3 A 5-nm 60-GS/s 7b 64-Way Time Interleaved Partial Loop Unrolled SAR ADC Achieving 35.2dB SNDR up to 32 GHz\n4 An Eight-Lane 800-Gb/s Transceiver for PAM-4 Optical Direct-Detection Applications in 5-nm FinFET Process\n","permalink":"https://danielhacks.it/about/","summary":"\u003ch2 id=\"who-am-i\"\u003eWho am I?\u003c/h2\u003e\n\u003cfigure class=\"align-center \"\u003e\n    \u003cimg loading=\"lazy\" src=\"/images/itsmedaniel.jpg#center\"\n         alt=\"Personal shot\"/\u003e \u003cfigcaption\u003e\n            \u003cp\u003eValeggio, 2023\u003c/p\u003e\n        \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eI\u0026rsquo;m Daniel, a microelectronics engineer working on cutting edge optical links, but with a general passion for electronics since I was 13 years old. Based in Italy, from the best analog microelectronics school around (and they know it).\u003c/p\u003e\n\u003ch2 id=\"what-is-this-blog-about\"\u003eWhat is this blog about\u003c/h2\u003e\n\u003cp\u003eIn principle, I wanted to make a web log for my learning activity on digital design and FPGA. But well in the deep, I\u0026rsquo;m an analog circuit designer, and even deeper, a physicist. So I guess at some point the arguments will diverge onto many of my interests. But what blog writer doesn\u0026rsquo;t do that?\u003c/p\u003e","title":"About"},{"content":"Here is an organized collection of the resources I leverage when doing some kind of research. Google is obvious, so let\u0026rsquo;s skip it.\nGeneral Electronics Analog Electronics Digital Electronics ","permalink":"https://danielhacks.it/resources/","summary":"\u003cp\u003eHere is an organized collection of the resources I leverage when doing some kind of research. Google is obvious, so let\u0026rsquo;s skip it.\u003c/p\u003e\n\u003ch3 id=\"general-electronics\"\u003eGeneral Electronics\u003c/h3\u003e\n\u003ch3 id=\"analog-electronics\"\u003eAnalog Electronics\u003c/h3\u003e\n\u003ch3 id=\"digital-electronics\"\u003eDigital Electronics\u003c/h3\u003e","title":"Resources"},{"content":"Let me be brief, as this is just to fill the emptyness of a newly created blog: I want to learn new skills and take notes that can be shared with people in the hope they will find useful as well.\nIn this blog I have the plan to showcase my personal projects on electronics and perhaps other fields, maybe adding some of the knowledge I have accumulated in the last years in the field (if it doesn\u0026rsquo;t break any NDA, of course).\nWith this being said, have a good reading.\nWith regards\nDaniel\n","permalink":"https://danielhacks.it/blog/20250525_introduction/","summary":"\u003cp\u003eLet me be brief, as this is just to fill the emptyness of a newly created blog: I want to learn new skills and take notes that can be shared with people in the hope they will find useful as well.\u003c/p\u003e\n\u003cp\u003eIn this blog I have the plan to showcase my personal projects on electronics and perhaps other fields, maybe adding some of the knowledge I have accumulated in the last years in the field (if it doesn\u0026rsquo;t break any NDA, of course).\u003c/p\u003e","title":"Blog introduction"}]