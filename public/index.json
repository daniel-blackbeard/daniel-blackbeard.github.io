[{"content":"Introduction Last time we did together a circuit using verilog to communicate to a I2S device. But we never delved into how to make a waveform for it.\nNow, don\u0026rsquo;t get me wrong: if you did the blinky led example while starting your first projects, this can be easily achievable for you:\nA square pattern is just zeros and ones A saw pattern is a counter from zero to max A triangle wave is a counter that goes back after hitting max or min values A sine wave is just some CORDIC\u0026hellip; Now, we will not be using CORDIC and will not be doing simple counters. I want to show you a couple of tricks to generate a clean sine waveform that you can later compose to create more fancy sounds.\nSingle LUT1 Instead of CORDIC, we will encode the values of the sine function within a lookup table (LUT) and then use the values and transform them as needed. This will allow us to create a shape that resembles the trigonometric function, just without frequency content. Instead, for the frequency we will use a counter and call it phase accumulator because it sounds better. This counter will keep track of the phase per time step (clock or strobe), hence the frequency will be directly a ratio between the phase advancement and this time step.\nSine ROM Let\u0026rsquo;s take a look at the ROM:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 data[0] = 8\u0026#39;b00000000; data[1] = 8\u0026#39;b00000110; data[2] = 8\u0026#39;b00001100; data[3] = 8\u0026#39;b00010010; data[4] = 8\u0026#39;b00011001; data[5] = 8\u0026#39;b00011111; data[6] = 8\u0026#39;b00100101; data[7] = 8\u0026#39;b00101011; data[8] = 8\u0026#39;b00110001; data[9] = 8\u0026#39;b00111000; data[10] = 8\u0026#39;b00111110; data[11] = 8\u0026#39;b01000100; data[12] = 8\u0026#39;b01001010; data[13] = 8\u0026#39;b01010000; data[14] = 8\u0026#39;b01010110; data[15] = 8\u0026#39;b01011100; data[16] = 8\u0026#39;b01100001; data[17] = 8\u0026#39;b01100111; data[18] = 8\u0026#39;b01101101; data[19] = 8\u0026#39;b01110011; data[20] = 8\u0026#39;b01111000; data[21] = 8\u0026#39;b01111110; data[22] = 8\u0026#39;b10000011; data[23] = 8\u0026#39;b10001000; data[24] = 8\u0026#39;b10001110; data[25] = 8\u0026#39;b10010011; data[26] = 8\u0026#39;b10011000; data[27] = 8\u0026#39;b10011101; data[28] = 8\u0026#39;b10100010; data[29] = 8\u0026#39;b10100111; data[30] = 8\u0026#39;b10101011; data[31] = 8\u0026#39;b10110000; data[32] = 8\u0026#39;b10110101; data[33] = 8\u0026#39;b10111001; data[34] = 8\u0026#39;b10111101; data[35] = 8\u0026#39;b11000001; data[36] = 8\u0026#39;b11000101; data[37] = 8\u0026#39;b11001001; data[38] = 8\u0026#39;b11001101; data[39] = 8\u0026#39;b11010001; data[40] = 8\u0026#39;b11010100; data[41] = 8\u0026#39;b11011000; data[42] = 8\u0026#39;b11011011; data[43] = 8\u0026#39;b11011110; data[44] = 8\u0026#39;b11100001; data[45] = 8\u0026#39;b11100100; data[46] = 8\u0026#39;b11100111; data[47] = 8\u0026#39;b11101010; data[48] = 8\u0026#39;b11101100; data[49] = 8\u0026#39;b11101110; data[50] = 8\u0026#39;b11110001; data[51] = 8\u0026#39;b11110011; data[52] = 8\u0026#39;b11110100; data[53] = 8\u0026#39;b11110110; data[54] = 8\u0026#39;b11111000; data[55] = 8\u0026#39;b11111001; data[56] = 8\u0026#39;b11111011; data[57] = 8\u0026#39;b11111100; data[58] = 8\u0026#39;b11111101; data[59] = 8\u0026#39;b11111110; data[60] = 8\u0026#39;b11111110; data[61] = 8\u0026#39;b11111111; data[62] = 8\u0026#39;b11111111; data[63] = 8\u0026#39;b11111111; In here, I encoded the values of the sine function from zero to pi/2. This is because to save memory and resource, we would rather leverage on the sine symmetries and make a little calculation depending on the phase.\nThe resolution of this function is 8bit and there are 64 values. This means that using the symmetries, we add a sign, making a 9bit value for a total of 256 samples per period. If we use as sampling rate the same we used in the former blog about I2S, so 48KHz, that means that a full period will be of 48KHz/256 or 187.5Hz. This basically defines the frequency resolution, and as such, I don\u0026rsquo;t like this number. So I will boost artificially the number of samples in the LUT by using linear interpolation. This interpolation at the same time will boost by additional bits the resolution of the signal with some penalty on the Signal to Noise plus Distortion Ratio (SNDR) with respect to use a bigger and more accurate LUT, but with huge savings in power, area and complexity.\nSynthesizer We use this sine ROM with a circuit that fetch the values by encoding the phase into a memory address and transforms it into a complete waveform. So let\u0026rsquo;s put some framework to begin with:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // It produces samples at ~48KHz, that given the constraints of i2s_tx module // means we can use a frequency of 60MHz and a divisor of 1248 // the frequency error will be around 0.16% parameter DIV = 12\u0026#39;b10011011111; reg [11:0] strobe; reg [17:0] phase_accum; // each bit increases freq by 0.732Hz, we will use sine symmetries wire [7:0] samp; reg [8:0] data, data_last; // this is the actual waveform, on this we will make interpolation reg [5:0] addr; reg [23:0] dtemp, dtemp_interp; initial begin addr = 6\u0026#39;b0; strobe = 12\u0026#39;b0; phase_accum = 18\u0026#39;b0; data = 9\u0026#39;b0; data_last = 9\u0026#39;b0; d_out = 24\u0026#39;b0; end We have as inputs a clock, that for compatibility with the I2S circuit, will be 60MHz, we will need a volume control, the phase step per time step (proxy of the frequency) and put out the current value of the numerical oscillator.\nLet\u0026rsquo;s see how to make this quarter of wave into a complete wave:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 always @(phase_accum, samp) begin case(phase_accum[17:16]) 2\u0026#39;b00: addr \u0026lt;= phase_accum[15:10]; 2\u0026#39;b01: addr \u0026lt;= 6\u0026#39;b111111 - phase_accum[15:10]; 2\u0026#39;b10: addr \u0026lt;= phase_accum[15:10]; 2\u0026#39;b11: addr \u0026lt;= 6\u0026#39;b111111 - phase_accum[15:10]; endcase case(phase_accum[17:16]) 2\u0026#39;b00: data \u0026lt;= {1\u0026#39;b0, samp}; 2\u0026#39;b01: data \u0026lt;= {1\u0026#39;b0, samp}; 2\u0026#39;b10: data \u0026lt;= {1\u0026#39;b1, ~samp}; 2\u0026#39;b11: data \u0026lt;= {1\u0026#39;b1, ~samp}; endcase end Not sure if intuitive enough, but basically two things happen in here:\nOn even quadrants the address to the room goes to the other side to have continuity after pi/2 and 3pi/2. On third and fourth quadrant, the sine changes sign, hence we add this sign and transform into 2-complement signed value Then, we update via synchronous logic the strobe (to convert from 60MHz to 48KHz), the phase accumulator and keep track of the last value of the ROM. Consider that we will move only forward in phase here.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 always @(posedge clk) begin if(strobe==DIV) begin strobe \u0026lt;= 12\u0026#39;b0; phase_accum \u0026lt;= phase_accum + f_mult; data_last \u0026lt;= ((phase_accum\u0026gt;\u0026gt;10) != (phase_accum + f_mult)\u0026gt;\u0026gt;10) ? data : data_last; end else begin strobe \u0026lt;= strobe + 12\u0026#39;b1; end // This will attempt to infer DSP slices // Linear interpolation here dtemp \u0026lt;= {{15{data[8]}}, data} - {{15{data_last[8]}}, data_last}; dtemp_interp \u0026lt;= dtemp*phase_accum[9:0] + ({{15{data_last[8]}}, data_last}\u0026lt;\u0026lt;10); d_out \u0026lt;= dtemp_interp * vol; end You can see, data_last changes only when the data from the calculation made on the ROM values changes itself. This value will be used for linear interpolation.\nLinear interpolation Let\u0026rsquo;s put it blunt in here because either you know what it is, or you don\u0026rsquo;t: between two points on the sine table, we will draw a line and divide it by a power of two number of points. This is not necessarily a good approximation, but the quantization error made is way smaller with respect to not doing anything.\nThe white dots are the values in the LUT, the curve is the theoretical values of the function in continuous time, the black dots are inferred from a line between the white dots.\nThe values at the middle points between two values of the LUT follow a simple linear relationship. Basically divide the $\\Delta Y$ by the $\\Delta \\phi = X_{n+1} - X_{n}$ to obtain the slope, then multiply by the current slice in the phase and add the last value:\n$$ Y_n = \\frac{Y_{n+1} - Y_{n}}{X_{n+1} - X_{n}}m $$\nhere, $m$ is the current slice between 2 points in the LUT. We will choose a power of 2 for the maximum value of $m$ for simplicity, but it can be any value. The trick here, is that the maximum value of $m$ is equivalent to the number of slices between $X_{n+1} - X_{n}$, and if this value is a power of 2, then the division becomes a left shift. Actually, we don\u0026rsquo;t even have to do this shift, as the data is 9bit (8 + 1 of sign) and we extended by additional 15bit up to 24bit. Hence, we can just make a rest and call it a day. Then, what we do instead is leverage on the 18bit phase accumulator and make the next partition:\nbit [17:16] tracks the sine quadrant bit [15:10] tracks the address in the sine ROM bit [9:0] are used for interpolation So we can assume 18bit data with huge chunks of quantization, shift back 10bit, subtract, then multiply by the interpolation partition that tracks the current slice between to ROM points. The data is already shifted so few less circuits for us.\nWith 10 bits of interpolation, we are converting the 8bit ROM data into 18bit, add one for the sign, and then we can multiply this value for the volume setting, getting a total of 24bit data to the I2S circuit.\nNeat, isn\u0026rsquo;t?\nOne more notes about the interpolation: by using the multiplication with this recipe, we are leveraging on the DSP slices in the Artix 7 FPGA, there are something like 120 or so of those slices, so they are kind of precious and is better to save them for critical calculations. In this example we just used two of those for a synthesizer.\nConclusion This is just a toy example of how to make a LUT based synthesizer. More improvements can be made and perhaps I will. You can send this 24bit data and chain it with the I2C circuit we did last time, put headphones and listen the result.\nAs usual, if you want to get the sources of these blocks, as I write this blog I will place them at my github repo\nDisclaimer: don\u0026rsquo;t abbreviate the word \u0026ldquo;Single\u0026rdquo; please.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://danielhacks.it/blog/20250608_sine_synthesis_on_fpga/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eLast time we did together a circuit using verilog to communicate to a I2S device. But we never delved into how to make a waveform for it.\u003c/p\u003e\n\u003cp\u003eNow, don\u0026rsquo;t get me wrong: if you did the blinky led example while starting your first projects, this can be easily achievable for you:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA square pattern is just zeros and ones\u003c/li\u003e\n\u003cli\u003eA saw pattern is a counter from zero to max\u003c/li\u003e\n\u003cli\u003eA triangle wave is a counter that goes back after hitting max or min values\u003c/li\u003e\n\u003cli\u003eA sine wave is just some \u003ca href=\"https://en.wikipedia.org/wiki/CORDIC\"\u003eCORDIC\u003c/a\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNow, we will not be using CORDIC and will not be doing simple counters. I want to show you a couple of tricks to generate a clean sine waveform that you can later compose to create more fancy sounds.\u003c/p\u003e","title":"Sine Synthesis with FPGA"},{"content":"Introduction As you perhaps know, I\u0026rsquo;m working on this blog also as a way to log my learning journey. So, to support the lack of interesting peripherals on the Arty A7, I bought a set of modules for Arduino. Most of them quite uninteresting, but I got this I2S DAC module from Adafruit that implements the UDA1334A from NXP (datasheet).\nThis device interest me the most among the ones I got from the assortment, because since I was a kid I wanted to make my own guitar effects (in fact, I believe many electronic engineers are born this way or similar), so the end goal is quite ambitious as you can see. But let\u0026rsquo;s start from something easy.\nI2S protocol I2S (not to be confused with I2C, it\u0026rsquo;s a different thing) is a serial protocol for transmitting audio that needs three wires:\nLeft and Right selection, called Word Select (WS) Data stream A clock for sampling the data (BCK) Those three elements have simple rules:\nThe data stream has to be at least 8bit (24bit is best) of signed data The MSB is transmitted first The WS makes its transition during the falling edge of the BCK After the WS transition, the LSB is processed to give time to the receiver to elaborate the stream before switching audio side So, basically the stream will look something like this: WS comes before the data stream ends\nWith this said, let\u0026rsquo;s take a look at a simple implementation in systemVerilog for this circuit.\nImplementation From a module perspective, I want to make it very easy with few requirements for the modules that will use this one. Hence, we will need a clock, the input data to be sent, the tree outputs to the I2S receiver and a invert flag in case I wanted to exchange the left and right audio channels. The user of this module will be in charge of sending the data at the right moment with the wide timing margin that the WS offers.\nI will send 24bit data at 48KHz because it\u0026rsquo;s easy. This way, I can start from 60MHz clock I will generate by using a PLL in the Artix 7 FPGA and use a strobe to generate all the other signals. A counter from zero to the division ratio will act as state for the system.\nThe divisor has to be such that takes 60MHz to 48KHz audio as suggested before, but the streamed data is serial, so the BCK will have a clock frequency of 24bit x 2(LR channel) x 48KHz = 2.304MHz. Now, it just happens that is hard to make perfect ratios for the many clocks I plan to use, so I will settle with a divide ratio of 26, accepting a non-audible sampling rate at the UDA1334A of 0.16% higher frequency. Not a bad deal.\nSo, all together, this will end like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 always @(posedge clk) begin if(strobe==6\u0026#39;b011001) begin temp \u0026lt;= (counter == 5\u0026#39;b1) ? data_in : {temp[22:0], 1\u0026#39;b0}; strobe \u0026lt;= 6\u0026#39;b0; counter \u0026lt;= (counter == 5\u0026#39;b10111) ? 5\u0026#39;b0 : counter + 5\u0026#39;b1; dx_or_sx \u0026lt;= (counter == 5\u0026#39;b0) ? ~dx_or_sx : dx_or_sx; end else begin strobe \u0026lt;= strobe + 6\u0026#39;b1; end end assign ws = invert ? ~dx_or_sx : dx_or_sx; assign i2c_out = temp[23]; assign bck = strobe \u0026gt; 6\u0026#39;b001100 ? 1\u0026#39;b1 : 1\u0026#39;b0; Quite easy as promised.\nSo, when the strobe is 6'b011001, the strobe is reset and the state is increased by 1. If the state is zero it switches the audio channel, then when the state is 1 loads the next piece of data. The BCK is just a cheap 1bit alternating counter, as making this with PLL is not possible.\nIn simulation, we can obtain this: A stream of 24\u0026rsquo;hE38E38 is sent here\nConclusion This piece of verilog, together with a I2S capable device, will allow you to send pieces of audio waveform out to the external world. This is the first step for making a small synthesizer (on the next post) and in the future a complete digital audio processor.\nIf you want to get the sources of these blocks, as I write this blog I will place them at my github repo\n","permalink":"https://danielhacks.it/blog/20250608_digital_audio_with_i2s/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eAs you perhaps know, I\u0026rsquo;m working on this blog also as a way to log my learning journey. So, to support the lack of interesting peripherals on the Arty A7, I bought a set of modules for Arduino. Most of them quite uninteresting, but I got this I2S DAC module from \u003ca href=\"https://www.adafruit.com/product/3678\"\u003eAdafruit\u003c/a\u003e that implements the UDA1334A from NXP (\u003ca href=\"https://www.nxp.com/docs/en/data-sheet/UDA1334ATS.pdf\"\u003edatasheet\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eThis device interest me the most among the ones I got from the assortment, because since I was a kid I wanted to make my own guitar effects (in fact, I believe many electronic engineers are born this way or similar), so the end goal is quite ambitious as you can see. But let\u0026rsquo;s start from something easy.\u003c/p\u003e","title":"Digital audio with I2S"},{"content":"Introduction So, after you are done with the book and implemented your first 8-bit CPU you keep wondering\nok, but now I want to do real world stuff\nHere I got you back, nothing comes before when it comes to real world stuff that having the capability of sending data to/from other devices. When I began my personal projects, when I got my Arty A7, I thought that I needed to be able to debug what\u0026rsquo;s happening inside the FPGA when the internal logic analyzer might not be too reliable (pro-tip: it\u0026rsquo;s very reliable). So being able to send to a computer data using a simple protocol is a must.\nUART comes as the best option for easy communication, as the baudrate is not too high to need complicated timing analysis, but complex enough to be a funny first project to learn the basics of digital design applied to real world, with real constraints and specifications.\nWhat is this UART then? UART (universal asynchronous receiver-transmitter) is a serial protocol of communication that doesn\u0026rsquo;t require tight clock sync between transmitter (TX) and receiver (RX). Basically, the TX pulls the wire down to tell the RX that it needs to start listening, sends some bits of data one at time, maybe some parity bits and ends the transmission by setting the wire to high. Indeed, the wire is in resting state when it\u0026rsquo;s kept high.\nExample of UART signal\nAs you can see from the picture, 8 bits are sent, no parity bit is sent, there is the starting signal (pull down) and the end signal (pull up). The transmission is in idle when the wire is kept high. The other condition is that the least significant bit (LSB) is sent first. For example, in the transmission above, the byte 8'h4B will be sent starting by the h4 symbol, just reversed, later the hB symbol, reversed as well.\nHow do I implement the UART thing? Even before writing a single line of code, let\u0026rsquo;s put down a strategy on how to make this block and also how to verify it.\nFunctional blocks So, we have for the UART the transmitter TX and the receiver RX. The properties of those blocks should be such when there is a signal to enable communication they will start processing in a blocking way, that means they will process one byte at time and notify when this processing is finished so that the next one can start. From a top level perspective, we have then:\nUART blocks\nBasically, we will need two blocks: the TX that will get the data, the starting signal and return the UART stream to the PC and a notification when it\u0026rsquo;s done, and the RX that will get the incoming stream from the PC and notify when it\u0026rsquo;s done, providing the data at it\u0026rsquo;s output.\nHow do I verify this is working? We will have to prepare a testbench, where we will chain some UART input data, use the RX to decode the stream, then send this very same data to the TX, where the expected result should be a UART stream that is equal but delayed as the input signal, very easy for verification, but since I\u0026rsquo;m kind of lazy, I will chain another RX, and make sure that the chaining of data-\u0026gt;RX-\u0026gt;TX-\u0026gt;RX yields the same decoded data.\nSo, let\u0026rsquo;s see at the details of each block now\nTX The TX, as indicated in the picture above, takes an input data from a register, the order to start transmitting, and it will raise a busy flag while it\u0026rsquo;s serializing the data to indicate a potential FIFO or whatever is feeding with data the TX to not send any more until the flag is lowered. However, the TX should be ready to start as soon as it\u0026rsquo;s finished. For this, it comes to help the ending bit: while it\u0026rsquo;s pulled up for one period, the TX gets ready to receive the next byte of data.\nTo do this, we will rely on a finite state machine (FSM from now on), indicating at what step of the process the transmitter is. We will also be indicating at the block the baud rate for the transmission and since I\u0026rsquo;m using for this particular example the clock of the Arty A7 (100MHz), I will indicate this as a parameter. The goal is to tell the circuit, via a counter, how many clock cycles each period of the UART signal requires to transition to the next state\n1 2 3 4 5 6 7 8 parameter SYSCLK = 100_000_000; // MHz parameter BAUDRATE = 57600; parameter DIVISOR = SYSCLK/BAUDRATE; enum reg [3:0] {IDLE, INIT, BIT8, BIT7, BIT6, BIT5, BIT4, BIT3, BIT2, BIT1, BIT0} state=IDLE, next_state=IDLE; reg [8:0] temp_buf = 9\u0026#39;b111111111; reg [13:0] strobe = 14\u0026#39;b1; The strobe signal is this counter, and when the counter reaches the required number of clock cycles, it will reset and command the next state to take over. Also, you can see I\u0026rsquo;m not explicitly indicating the final state, as I will consider as an idle state that will be capable of already receiving commands for the next byte to be transmitted.\nFor the sake of verification on simulation, I will be indicating an initial state for some variables. Those lines aren\u0026rsquo;t necessarily synthesizable, but are of great help and will avoid a lot of debugging later on simulation. Then, the main process is placed under a flip-flop (that posedge mixed with reg in its content). As you can see, when the strobe reach zero, the state is updated, the counter is reset to the value of DIVISOR and the output is set to the newest bit, else it will keep counting down. Another feature, if we are in the IDLE state we don\u0026rsquo;t count, the circuit is frozen. This is not that useful but I don\u0026rsquo;t like polar bears swimming around Italy because global warming.\n1 2 3 4 5 6 7 initial {txd, tx_busy} = {1\u0026#39;b1, 1\u0026#39;b0}; always @(posedge clk) begin {state, txd} \u0026lt;= (strobe == 14\u0026#39;b0) ? {next_state, temp_buf[0]} : {state, txd}; if (strobe == 14\u0026#39;b0) strobe \u0026lt;= (next_state == IDLE) ? 14\u0026#39;b0 : DIVISOR - 1; else strobe \u0026lt;= strobe - 14\u0026#39;b1; end Finally, we define the transitions of the state machine and assign the busy flag up whenever we are busy processing data. Also, notice we are updating the temp_buf as a shift register. This is another subtlety, as it\u0026rsquo;s more expensive to place many switches on the place of the requested array than just shift the data and take the last bit. This will also help with filling with 1'b1s, so that\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 always @(posedge clk) begin case(state) IDLE: {next_state, temp_buf} \u0026lt;= (i_wr \u0026amp;\u0026amp; !tx_busy) ? {INIT, {data, 1\u0026#39;b0}} : {next_state, temp_buf}; INIT: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT8, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT8: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT7, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT7: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT6, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT6: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT5, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT5: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT4, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT4: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT3, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT3: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT2, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT2: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT1, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; BIT1: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {IDLE, {1\u0026#39;b1, temp_buf[8:1]}} : {next_state, temp_buf}; endcase end assign tx_busy = state!=IDLE; There you got, as promised an easy block, few lines of HDL where we abide to basic rules of digital design. Now let\u0026rsquo;s take a look at the receiver\nRX This block is not more complicated, but it has a subtletly: a real line when idle, for any reason, can be pulled by noise, cross talking, electromagnetic interference, etc. into a low state. This is a false positive for the starting of the transmission and we don\u0026rsquo;t want to catch it. Also, unlike the transmitter, we want to sample the data not at the begining but at the middle of the UART period, this is because you never know the quality of the signal you are receiving, and if the cable is very long, lossy or don\u0026rsquo;t have enough power to driver the RX input capacitance, the signal might not settle correctly if we don\u0026rsquo;t give it enough time.\nSo, in the same ways as before, we define some parameters for the baud rate, the initial value of some variables and the states of the RX:\n1 2 3 4 5 6 7 8 9 10 parameter SYSCLK = 100_000_000; // MHz parameter BAUDRATE = 57600; parameter DIVISOR = SYSCLK/BAUDRATE; enum reg [3:0] {IDLE, BIT8, BIT7, BIT6, BIT5, BIT4, BIT3, BIT2, BIT1, BIT0} state=IDLE, next_state=IDLE; reg [13:0] strobe = 14\u0026#39;b0; reg [7:0] temp_buf = 8\u0026#39;b11111111; initial data = 8\u0026#39;b0; The logic on the state machine. Same as before, if the state is in IDLE we just stop the counter. Here, we also define the rule for updating the output in such a way that hides the inner process, setting it at the final value only when we are about to set the state into idling.\n1 2 3 4 5 6 7 8 9 always @(posedge clk) begin state \u0026lt;= (strobe == 14\u0026#39;b0) ? next_state : state; if (strobe == 14\u0026#39;b0) strobe \u0026lt;= ((state == IDLE) \u0026amp; rxd) ? 14\u0026#39;b0 : DIVISOR - 1; else strobe \u0026lt;= strobe - 14\u0026#39;b1; end always @(posedge clk) begin data \u0026lt;= (next_state==IDLE) ? temp_buf : data; end Finally, the update rules for the FSM, and we set the flag for the rx_done to one, but only for one clock cycle. This is because this way I can chain a RX and a TX and make echo requests with the UART. Also, notice that we set the next_state at the middle of the counter for the reasons indicated at the beginning of this section\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 always @(posedge clk) begin case(state) IDLE: {next_state, temp_buf} \u0026lt;= ((strobe==DIVISOR/2) \u0026amp; !rxd) ? {BIT8, {8\u0026#39;b00000000}} : {next_state, temp_buf}; BIT8: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT7, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT7: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT6, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT6: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT5, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT5: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT4, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT4: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT3, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT3: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT2, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT2: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {BIT1, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; BIT1: {next_state, temp_buf} \u0026lt;= (strobe==DIVISOR/2) ? {IDLE, {rxd, temp_buf[7:1]}} : {next_state, temp_buf}; endcase end assign rx_done = (state==IDLE) \u0026amp; (next_state==IDLE); Simulation For testing this block, I will feed the RX with some premade data stream, and chain RX to TX to RX and check the values of the processed data and the UART signals. Also, via parameter, I will set the baud rate of the UART to 25Mbaud, so that the counter needs to count 4 clocks and the simulation doesn\u0026rsquo;t get too long.\n1 2 3 4 5 6 7 8 9 10 parameter BAUDRATE = 25000000; reg tb_clk = 1\u0026#39;b0; reg [29:0] pattern = {1\u0026#39;b1,8\u0026#39;h5A,1\u0026#39;b0,1\u0026#39;b1,8\u0026#39;hC6,1\u0026#39;b0,1\u0026#39;b1,8\u0026#39;hE6,1\u0026#39;b0}; reg [4:0] npat = 5\u0026#39;b11101; assign rxd = pattern[npat]; always #10 tb_clk \u0026lt;= !tb_clk; always #80 npat \u0026lt;= npat==29 ? 5\u0026#39;b00000 : npat + 1; The resulting signals are as follows:\nUART Simulation in Vivado\nIn the picture you can see the RX received the stream defined in reg [29:0] pattern and when it\u0026rsquo;s done it pass directly the data to the TX, then the TX will process and send the data to the verification RX, hence there will be a delay from TX to verification RX of about 9 symbols, without wasting clock cycles between one byte and another.\nConclusion Together with you, this is the first block I created in my Arty A7 that I can consider a complete project. It pass a complete run of simulation and when implemented in the FPGA the echo functionality works. My next steps it\u0026rsquo;s to stress test this block by making a loop and sending pseudo-random data while checking the bit error rate.\nIf you want to get the sources of these blocks, as I write this blog I will place them at my github repo\n","permalink":"https://danielhacks.it/blog/20250529_uart_for_practice/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eSo, after you are done with the book and implemented your first 8-bit CPU you keep wondering\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eok, but now I want to do real world stuff\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eHere I got you back, nothing comes before when it comes to real world stuff that having the capability of sending data to/from other devices. When I began my personal projects, when I got my Arty A7, I thought that I needed to be able to debug what\u0026rsquo;s happening inside the FPGA when the internal logic analyzer might not be too reliable (pro-tip: it\u0026rsquo;s very reliable). So being able to send to a computer data using a simple protocol is a must.\u003c/p\u003e","title":"UART: the basics after you know the very basics"},{"content":"Introduction If you are a hardware engineer you need no explanation though, this is more for the programming guys who attempt to make things with an FPGA in the belief that is the next step of Arduino (I do think that though, so no judgment made here)\nAs someone who wrote a lot of code in my young age (still loving fiddling with Linux kernel), I\u0026rsquo;m lucky I got the purpose of HDL.\nGiven the amount of times I have seen the question raised on stackoverflow or reddit on the struggle of programmers that approach the field of digital design, this is not a wasted question. So what is even HDL?\nWhat is HDL? Basically it stands for Hardware Definition Language. Still a language but not for programming on a Turin machine.\nSo, for the software programming team, but those who do real programming (hence know at least Lisp, preferable Haskell), this is kind of functional language. It is actually a netlist language, where you describe the connections of digital circuitry, input to the block (HDL module) and the outputs that will go somewhere. And this pretty much resembles the behavior of functions (more than zero inputs, at least one output). So, if you know your functionals languages, you will fare very well with HDL. Else I pretty much recommend Haskell as your next step in programming muscles.\nIn this blog I will mainly write in SystemVerilog, a superset of Verilog, which is one of the most popular hardware definition languages. The other one that is out there is VHDL. As usual, they both are capable of doing pretty much what\u0026rsquo;s needed for having the job done, it\u0026rsquo;s a matter of preference (or what you are forced to use in your workplace).\nWhat is this wire and reg In logic design you have ones and zeros. Sometimes some floating piece of metal that is not connected to anything of something which you can\u0026rsquo;t tell what\u0026rsquo;s the current state when you plug a supply (remember, we are still talking about circuits, forget definite initial states).\nA wire is an element that alike a real wire, can carry information from point A to point B. That\u0026rsquo;s all. In HDL, you need to define wires so that you can differentiate by labels the connections from one module to another. An example in here:\n1 2 3 4 wire bus_in1, bus_in2; wire bus_out; assign bus_out = and(bus_in1, bus_in2); Let me reiterate once again: we are dealing with logic, which is akin to functions (some inputs, at least one output). With wires, we defined where this and() element (the circuit for the logic AND operation) is connected. Perhaps also which whom.\nThey are just labels you use to identify connections\nInstead, the reg is just like a wire that can store its state, like a memory element. Here comes the confusion oftentimes, as a wire is not a complicated circuit, just a piece of conductor. Instead, whatever gets synthesized by a reg ends having some transistors. Hence, a reg will synthesize either a latch (a memory element that\u0026rsquo;s dependent on the level) or a flip-flop (a memory element that\u0026rsquo;s dependent on the transition of a control signal, almost always a clock).\nIf you don\u0026rsquo;t know what latches or flipflops are, here is a brief explanation:\nA latch is a memory element that sets the output equal to the input when actively driven. When no driving is given to the latch (no electrons in the input, or floating input) it preserves the last state. A flip-flop will propagate the state of the input to the output only when a transition either from zero to one (raising or positive edge) or from one to zero (falling or negative edge) happens.\nAs a general rule, in digital design you avoid latches as are very technology dependent on their implementation (they can be very power hungry sometimes). From now on let\u0026rsquo;s set the rule that we will try to synthesize only flip-flops.\nThey said HDL has intrinsic parallelism HLD is as much parallel as two logic gates working at the same time. You describe the logical circuits and nothing stops it from making two operations at the very same time (disregarding propagation delay in logic gates). In this way, the parallelism is really explicit.\nSo can I do a for loop? Hardware Definition Language!\nTry to make a for loop out of AND/OR/NOT gates on a breadboard. Sure you can, but there are better ways to make a loop that save components (fewer components, less area, less power wasted, polar bears not floating around Sicily).\nYup, when you shitpost on reddit global warming send beards to Sicily\nHowever, for all the effects, HDL is capable of parsing a for loop, as it will infer the attempt of the engineer and generate the equivalent circuit that reproduces that behavior. You can pretty much describe the behavior of your circuit in HDL, no warranties that the synthesis will be the best one for a certain algorithm.\nAgain, team Haskell wins here against team Java (lol). Recursion basically is a way of making pipelines in digital design.\nSo, am I ready to write HDL after reading this? Let\u0026rsquo;s be honest: you were always ready to make digital circuits, just that your mindset was obfuscated by the prejudice that HDL are programming languages. Now that you know they aren\u0026rsquo;t, and you know that they basically describe the connections and/or behavior of logical circuits, the doors are open for you. But for the sake of making a framework that will allow you to make good designs, let\u0026rsquo;s put this set of rules:\nWhen use the always @(posedge clk) or always @(negedge clk) to create flip-flops, strive for always and unconditionally use real clock signals. Avoid as much as possible using other signals Never synthezise latches. The synthesis tool usually reports when this happens, but a basic rule is to never put a reg variable under an always statement that doesn\u0026rsquo;t contain either posedge or negedge Avoid for or while loops as much as you can, the better you are, the less you need them. Abuse case(variable) whenever you can Avoid loops. In HDL everything happens at the same time, so something like this 1 2 3 4 5 always @(a, b, c) a = b; b = c; c = a; end will fail miserably as you just created a ring of buffers\n","permalink":"https://danielhacks.it/blog/20250527_what-is-hdl/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you are a hardware engineer you need no explanation though, this is more for the programming guys who attempt to make things with an FPGA in the belief that is the next step of Arduino (I do think that though, so no judgment made here)\u003c/p\u003e\n\u003cp\u003eAs someone who wrote a lot of code in my young age (still loving fiddling with Linux kernel), I\u0026rsquo;m lucky I got the purpose of HDL.\u003c/p\u003e","title":"What Is HDL? The explanation you did not requested"},{"content":"Who am I? Valeggio, 2023\nI\u0026rsquo;m Daniel, a microelectronics engineer working on cutting edge optical links, but with a general passion for electronics since I was 13 years old. Based in Italy, from the best analog microelectronics school around (and they know it).\nWhat is this blog about In principle, I wanted to make a web log for my learning activity on digital design and FPGA. But well in the deep, I\u0026rsquo;m an analog circuit designer, and even deeper, a physicist. So I guess at some point the arguments will diverge onto many of my interests. But what blog writer doesn\u0026rsquo;t do that?\nWhy is this blog necessary? I used to write blogs back in the 2010s about machine learning, data science and numerical simulation of complex systems. With the years I moved onto different things and removed the blog references. But in the end I like the learning process that allows the writing and summarizing information. If other people can understand it, that means I got it right. Akin to the teacher learning from the student, just that the student is me as well.\nSo basically, it is necessary for me, but with the hope that the quality is high enough so that you can leverage on this information as well.\nWhy there is that little shack in the navbar? Among many of my dreams, there is this dream of going off the grid (partially). So I\u0026rsquo;m looking for ways to have this small house in the mountains, some mini cows, mini donkeys, goats, chickens and Wi-Fi to keep doing what I love. This blog itself is a move towards that future, hence I see the point on putting a symbol of my end goal somewhere around where I don\u0026rsquo;t lose sight of it.\nPublications 1 A 200Gb/s Low Power DSP-Based Optical Receiver and Transmitter with Integrated TIA and Laser Drivers\n2 A 5nm 60GS/s 7b 64-Way Time Interleaved Partial Loop Unrolled SAR ADC Achieving 34dB SNDR up to 32GHz\n3 A 5-nm 60-GS/s 7b 64-Way Time Interleaved Partial Loop Unrolled SAR ADC Achieving 35.2dB SNDR up to 32 GHz\n4 An Eight-Lane 800-Gb/s Transceiver for PAM-4 Optical Direct-Detection Applications in 5-nm FinFET Process\n","permalink":"https://danielhacks.it/about/","summary":"\u003ch2 id=\"who-am-i\"\u003eWho am I?\u003c/h2\u003e\n\u003cfigure class=\"align-center \"\u003e\n    \u003cimg loading=\"lazy\" src=\"/images/itsmedaniel.jpg#center\"\n         alt=\"Personal shot\"/\u003e \u003cfigcaption\u003e\n            \u003cp\u003eValeggio, 2023\u003c/p\u003e\n        \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eI\u0026rsquo;m Daniel, a microelectronics engineer working on cutting edge optical links, but with a general passion for electronics since I was 13 years old. Based in Italy, from the best analog microelectronics school around (and they know it).\u003c/p\u003e\n\u003ch2 id=\"what-is-this-blog-about\"\u003eWhat is this blog about\u003c/h2\u003e\n\u003cp\u003eIn principle, I wanted to make a web log for my learning activity on digital design and FPGA. But well in the deep, I\u0026rsquo;m an analog circuit designer, and even deeper, a physicist. So I guess at some point the arguments will diverge onto many of my interests. But what blog writer doesn\u0026rsquo;t do that?\u003c/p\u003e","title":"About"},{"content":"Here is an organized collection of the resources I leverage when doing some kind of research. Google is obvious, so let\u0026rsquo;s skip it.\nGeneral Electronics Analog Electronics Digital Electronics ","permalink":"https://danielhacks.it/resources/","summary":"\u003cp\u003eHere is an organized collection of the resources I leverage when doing some kind of research. Google is obvious, so let\u0026rsquo;s skip it.\u003c/p\u003e\n\u003ch3 id=\"general-electronics\"\u003eGeneral Electronics\u003c/h3\u003e\n\u003ch3 id=\"analog-electronics\"\u003eAnalog Electronics\u003c/h3\u003e\n\u003ch3 id=\"digital-electronics\"\u003eDigital Electronics\u003c/h3\u003e","title":"Resources"},{"content":"Let me be brief, as this is just to fill the emptyness of a newly created blog: I want to learn new skills and take notes that can be shared with people in the hope they will find useful as well.\nIn this blog I have the plan to showcase my personal projects on electronics and perhaps other fields, maybe adding some of the knowledge I have accumulated in the last years in the field (if it doesn\u0026rsquo;t break any NDA, of course).\nWith this being said, have a good reading.\nWith regards\nDaniel\n","permalink":"https://danielhacks.it/blog/20250525_introduction/","summary":"\u003cp\u003eLet me be brief, as this is just to fill the emptyness of a newly created blog: I want to learn new skills and take notes that can be shared with people in the hope they will find useful as well.\u003c/p\u003e\n\u003cp\u003eIn this blog I have the plan to showcase my personal projects on electronics and perhaps other fields, maybe adding some of the knowledge I have accumulated in the last years in the field (if it doesn\u0026rsquo;t break any NDA, of course).\u003c/p\u003e","title":"Blog introduction"}]